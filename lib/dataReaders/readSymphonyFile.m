function DATA = readSymphonyFile(fileName)
% get h5 info
info = h5info(fileName);
fileInfo = cell(3,2);
[fileInfo{:,2}] = fileparts(which(fileName));
fileInfo(:,1) = {'filePath';'fileName';'fileExtension'};
% Check symphony version
attList = [{info.Attributes.Name}',{info.Attributes.Value}'];
symphonyVersion = attList{strcmpi(attList(:,1), 'version'),2};
DATA = struct();
if symphonyVersion < 2
  %symphony v1
  DATA.Notes = getNotesV1();
  DATA.Meta = getMetaV1();
  DATA.Data = getDataV1();
else
  %symphony v2
  nExperiments = length(info.Groups);
  % notes are 1xnExperiments cell array
  Notes = arrayfun(@getNotesV2, info.Groups, 'UniformOutput', false);
  Notes = cat(1, Notes{:});
  if nExperiments > 1
    Notes = cat(1,Notes{:});
    [~,sortOrder] = sort(Notes(:,1));
    Notes = {Notes(sortOrder,:)};
  end
  DATA.Notes = Notes;
  nGroups = numel(info.Groups);
  [Data,Meta] = deal(cell(1,nGroups));
  for gg = 1:nGroups
    Meta{gg} = getMetaV2(info.Groups(gg));
    Data{gg} = getDataV2(info.Groups(gg));
  end
  DATA.Meta = cat(1,Meta{:});
  DATA.Data = {cat(1,Data{:})};
end
DATA.Files = {fileName};
% return from here
%%% FUNCTIONS -------------------------------------------------------->

%% Version 1
% todo: add displayProperties to V1
function Notes = getNotesV1()
  %load the xml file
  [root,name,~] = fileparts(fileName);
  Notes = cell(1,2);
  try
    xmlFile = utilities.search_recurse([name,'_metadata'], 'root', root, 'ext', {'.xml'});
  catch 
    return;
  end
  Notes = XML2Notes(xmlFile);
end %notes
function Meta = getMetaV1()
  Meta = struct();
  % cellProperties = info.Groups.Groups;
  % cellAttributes = cellProperties(3).Attributes; % XXX indexing issue?
  % numerical index values, derived from cellAttributes(1:3).Name
  % 1. SourceID (i.e., 'WT')
  % 2. cellID (but we'll use fileName instead)
  % 3. rigName (which never changes and isn't used - omit until a problem occurs)

  rootName = info.Groups.Name;
  % /properties, /Epochs, /epochGroups
  % Gather some manual information from groups
  tmp = cell2struct(...
    {info.Groups(end).Attributes(ismember({info.Groups(end).Attributes.Name}', ...
                                          {'label','keywords'})).Value, ...
     info.Groups(end).Groups(3).Attributes(...
       ismember({info.Groups(end).Groups(3).Attributes.Name}', ...
                'sourceID')).Value...
    }', ...
    {info.Groups(end).Attributes(ismember({info.Groups(end).Attributes.Name}', ...
                                          {'label','keywords'})).Name, ...
     info.Groups(end).Groups(3).Attributes(...
       ismember({info.Groups(end).Groups(3).Attributes.Name}', ...
                'sourceID')).Name...
    }');
  Meta.Label = tmp.label;
  % Keywords from file
  try
    Meta.Keywords = tmp.keywords;
  catch
    Meta.Keywords = '';
  end
  % Source ID
  Meta.SourceID = tmp.sourceID;
  % user-chosen identifier for the cell
  Meta.FullFile = fileName;
  % XXX hard-code now, get from user later
  Meta.CellType = 'unknown'; 
  % Additional properties
  Meta.ExperimentStartTime = sec2str( ...
    h5readatt(fileName, ...
      rootName, ...
      'startTimeDotNetDateTimeOffsetUTCTicks' ...
      ), ...
    1e-7 ...
    );
  Meta.cellID = h5readatt(fileName, [rootName,'/properties'], 'cellID');
 
  % XXX hard-code now, get from user later
  Meta.OutputConfiguration = {'amp'; 'red'; 'orange'; 'blue'}; 
  % XXX hard-code now, get from user later
  Meta.OutputScaleFactor = {0; 19.3000; 30; 21}; 
  % XXX hard-code now, get from user later
  Meta.NDFConfiguration = {0; 0; 0; 0}; 
  % this is necessary for analysis program
  Meta.FamilyCondition.Label = {'Label'}; 
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.FamilyStepGuide = {'StmAmp'}; 
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.FamilyCueGuide = []; 
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.SegNum = 0;
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.PlotPref = 1;
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.ScaleFactorIndex = [];
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.DecimatePts = 1;
  % ??, copied from Kate's example CellInfo struct
  Meta.FamilyCondition.UserInfo = [];
  
end %meta
function Data = getDataV1()
  datumLocation = arrayfun( ...
    @(x)x.Groups(contains({x.Groups.Name}','/Epochs')).Groups, ...
    info.Groups, ...
    'UniformOutput', 0 ...
    );
  datumLocation = cat(1,datumLocation{:});
  nDatums = length(datumLocation);
  Data(nDatums,1) = struct( ...
    'protocols', {{}}, ...
    'displayProperties', {{}}, ...
    'id', '', ...
    'responses', struct() ...
    );
  for epNum = 1:nDatums
    curDatum = datumLocation(epNum);
    curNames = {curDatum.Groups.Name}';
    protos = find(contains(curNames, '/protocolParameters'),1);
    resps = find(contains(curNames, '/responses'),1);
    stims = find(contains(curNames, '/stimuli'),1);
    
    % Protocols
    Data(epNum,1).protocols = ...
      [ ...
        {curDatum.Groups(protos).Attributes.Name}', ...
        {curDatum.Groups(protos).Attributes.Value}' ...
      ];
    try
      Data(epNum,1).protocols( ...
        contains(Data(epNum,1).protocols(:,1), 'gitHash'), ...
        : ...
        ) = []; %drop gitHash if it's there.
    catch
    end
    dt = strsplit(Data(epNum,1).protocols{ ...
      contains(Data(epNum,1).protocols(:,1), 'dateAndTime'), ...
      2 ...
      }, ' ');
    Data(epNum,1).protocols( ...
      ismember(Data(epNum,1).protocols(:,1), 'dateAndTime'), ...
      : ...
      ) = [];
    Data(epNum,1).protocols = [ ...
      Data(epNum,1).protocols; ...
      {'Date', dt{1}; 'EpochStartTime',  dt{2}} ...
      ];
    % Display
    
    % Responses
    responseData = struct( ...
      'sampleRate', {{}}, ...
      'duration', {{}}, ...
      'units', {{}}, ...
      'device', {{}}, ...
      'x', {{}}, ...
      'y', {{}} ...
      );
    responseData.stimulusConfiguration = struct( ...
      'deviceName', '', ...
      'configSettings', struct('name', '', 'value', {{}}) ...
      );
    nDevices = length(curDatum.Groups(resps).Groups);
    for devNum = 1:nDevices
      curDev = curDatum.Groups(resps).Groups(devNum);
      responseData.devices{devNum} = h5readatt(fileName, ...
        curDev.Name, ...
        'deviceName' ...
        );
      fs = h5readatt(fileName, ...
        curDev.Name, ...
        'sampleRate' ...
        );
      responseData.sampleRate{devNum} = fs;
      d = h5read(fileName, [curDev.Name,'/data']);
      dur = length(d.quantity(:))/fs;
      responseData.duration{devNum} = dur;
      responseData.x{devNum} = linspace(0,dur-1/fs, dur*fs)';
      responseData.y{devNum} = d.quantity;
      responseData.units{devNum} = struct( ...
        'x', {'sec'}, ...
        'y', unique(cellstr(d.unit'),'stable') ...
        );
    end
    nStims = length(curDatum.Groups(stims).Groups);
    for stimNum = 1:nStims
      curStim = curDatum.Groups(stims).Groups(stimNum);
      currentDeviceName = h5readatt(fileName, curStim.Name, 'deviceName');
      responseData.stimulusConfiguration(stimNum).deviceName = currentDeviceName;
      try
        configInfo = h5info(fileName, ...
          sprintf( ...
            '%s/dataConfigurationSpans/span_0/%s', ...
            curStim.Name, ...
            currentDeviceName ...
          ) ...
          );
      catch
        continue;
      end
      nConfigs = length(configInfo.Attributes);
      for cf = 1:nConfigs
        responseData.stimulusConfiguration(stimNum).configSettings(cf).name = ...
          configInfo.Attributes(cf).Name;
        responseData.stimulusConfiguration(stimNum).configSettings(cf).value = ...
          {configInfo.Attributes(cf).Value};
      end
    end
    % get device configs
    responseData.deviceConfiguration = struct( ...
      'deviceName', '', ...
      'configSettings', struct('name', '', 'value', {{}}) ...
      );
    %
    Data(epNum,1).responses = responseData;
    
  end
  % reorder Data structs to get something resembling order
  [~,sortInds] = sort(...
    arrayfun( ...
      @(e) e.protocols{ismember(e.protocols(:,1), 'EpochStartTime'),2}, ...
    Data, ...
    'UniformOutput', 0 ...
    ) ...
    );
  Data = {Data(sortInds)}; %export as cell
end %data

%% Version 2
function Notes = getNotesV2(nfo)
  %nfo = info.Groups;
  %experiment notes come from nfo+'/notes'
  experimentNotes = struct('time',{''},'text',{''});
  try %#ok<TRYNC>
    data = h5read(fileName,[nfo.Name,'/notes']);
    [~,experimentNotes.time] = sec2str(data.time.ticks,data.time.offsetHours(1));
    experimentNotes.text = data.text;
  end
  
  %source notes
  sourceIndex = contains({nfo.Groups.Name}', '/sources');
  sourceGroups = nfo.Groups(sourceIndex); 
  sourceNotes(1:numel(sourceGroups.Groups),1) = struct('time',{''},'text',{''});
  if numel(sourceNotes) > 0
    for g = 1:numel(sourceGroups.Groups)
      try
        data = h5read(fileName,[sourceGroups.Groups(g).Name,'/notes']);
      catch
        continue
      end
      [~,sourceNotes(g).time] = sec2str(data.time.ticks,data.time.offsetHours(1));
      sourceNotes(g).text = data.text;
    end
  end

  %datumGroup notes
  groupIndex = ~cellfun(@isempty,...
    strfind({nfo.Groups.Name}', '/epochGroups'),'unif',1); %#ok
  datumGroups = nfo.Groups(groupIndex);
  blockNotes = struct('time',{''},'text',{''});
  if numel(datumGroups.Groups) > 0 
    % first get from group
    datumNotes = getNoteStruct({datumGroups.Groups.Name}');
    % then look for each experiment
    for I = 1:numel(datumGroups.Groups)
      datumBlockIndex = ~cellfun(@isempty,...
        strfind({datumGroups.Groups(I).Groups.Name}', '/epochBlocks'),'unif',1); %#ok
      datumBlocks = datumGroups.Groups(I).Groups(datumBlockIndex);
      % get each experiment for this epoch block
      try %#ok<TRYNC>
        blockNotes = [blockNotes;getNoteStruct({datumBlocks.Groups.Name}')];%#ok<AGROW>
      end
    end
  end

  Notes = cat(2,...
      cat(1,... %add times
        experimentNotes.time, ...
        sourceNotes.time, ...
        datumNotes.time, ...
        blockNotes.time ...
      ),...
      cat(1,... %add note texts
        experimentNotes.text, ...
        sourceNotes.text, ...
        datumNotes.text, ...
        blockNotes.text ...
      )...
    );
  if ~numel(Notes)
    Notes = {[{''},{''}]};
    return
  end
  [~,sid] = sort(Notes(:,1));
  Notes = {Notes(sid,:)};
  
  % HELPER FXN
  function nStruct = getNoteStruct(loc)
    if ~iscell(loc)
      loc = cellstr(loc);
    end
    nStruct(1:numel(loc),1) = struct('time',{''},'text',{''});
    for L = 1:numel(loc)
      try
        notedata = h5read(fileName,[loc{L},'/notes']);
      catch
        continue
      end
      [~,nStruct(L).time] = sec2str(notedata.time.ticks,notedata.time.offsetHours(1));
      nStruct(L).text = notedata.text;
    end
  end
end %notes  
function Meta = getMetaV2(grp)
  % grp is the hdf5 location of the current experiment. If you run multiple
  % 'experiment' types (Our version is is called "Electrophysiology") it will be
  % be aa cell array of multiple experiments (see the header of this function).
  [root,label,ext] = fileparts(fileName);
  % fing group's properties
  prpIndex = contains({grp.Groups.Name}', '/properties');
  Meta = cell2struct(...
    [ ...
      { ...
        [label,ext]; ...
        root ...
      }; ...
      { ...
        grp.Groups(prpIndex).Attributes.Value ...
      }' ...
    ], ...
    [ ...
      {'File';'Location'}; ...
      {grp.Groups(prpIndex).Attributes.Name}' ...
    ] ...
    );
  Meta.StartTime = ...
    sec2str( ...
      h5readatt(...
        fileName,...
        grp.Name,...
        'startTimeDotNetDateTimeOffsetTicks' ...
        ), ...
      h5readatt(...
        fileName,...
        grp.Name,...
        'startTimeDotNetDateTimeOffsetOffsetHours' ...
        ) ...
    );
  Meta.EndTime = ...
    sec2str( ...
      h5readatt(...
        fileName,...
        grp.Name,...
        'endTimeDotNetDateTimeOffsetTicks' ...
        ), ...
      h5readatt(...
          fileName,...
          grp.Name,...
          'endTimeDotNetDateTimeOffsetOffsetHours' ...
        ) ...
    );
  Meta.Purpose = h5readatt(fileName,grp.Name,'purpose');
  Meta.SymphonyVersion = h5readatt(fileName,info.Name,'symphonyVersion');
  % devices
  prpIndex = contains({grp.Groups.Name}', '/devices');
  deviceInfo = grp.Groups(prpIndex).Groups;
  nDevices = length(deviceInfo);
  %Meta.Devices = cell(1,nDevices);
  Meta.Devices = struct( ...
    'Name', '', ...
    'Manufacturer', '', ...
    'Resources', struct('name', '', 'value', []) ...
    );
  for deviceNum = 1:nDevices
    curName = deviceInfo(deviceNum).Name;
    tmpStr = struct();
    try
      tmpStr.Name = h5readatt(fileName,curName,'name');
    catch
      tmpStr.Name = sprintf('Device_%d',deviceNum);
    end
    
    try
      tmpStr.Manufacturer = h5readatt(fileName,curName,'manufacturer');
    catch
      tmpStr.Manufacturer = 'Unknown';
    end
    % add Resources here once I figure out how to capture them
    try
      resourceInfo = h5info(fileName,[curName,'/resources']);
      resourceTypes = arrayfun( ...
        @(rc) h5readatt(fileName,rc.Name,'name'), ...
        resourceInfo.Groups, ...
        'UniformOutput', 0 ...
        );
      % drop configuration settings ... ? Not sure if this is needed. Would like
      % to know config defaults.
      resourceInfo = resourceInfo.Groups( ...
        ~ismember(resourceTypes,'configurationSettingDescriptors') ...
        );
      resourceTypes = resourceTypes( ...
        ~ismember(resourceTypes,'configurationSettingDescriptors') ...
        );
      for g = 1:length(resourceInfo)
        rData = getArrayFromByteStream(h5read(fileName,[resourceInfo(g).Name,'/data']));
        tmpStr.Resources(g) = struct( ...
          'name', resourceTypes{g}, ...
          'value', rData ...
          );
      end
    catch
      tmpStr.Resources = struct('name', '', 'value', []);
    end
    if ~isfield(tmpStr,'Resources')
      tmpStr.Resources = struct('name', '', 'value', []);
    end
    Meta.Devices(deviceNum) = tmpStr;
  end
  prpIndex = contains({grp.Groups.Name}', '/sources');
  sourceLinks = grp.Groups(prpIndex).Links;
  sources = arrayfun( ...
    @(lnk)h5info(fileName,lnk.Value{1}), ...
    sourceLinks, ...
    'UniformOutput', 0 ...
    );
  nSources = numel(sources);
  S = cell(nSources,1);
  for sNum = 1:nSources
    curSource = sources{sNum};
    curSource = recurseSources(curSource);
    S{sNum} = curSource(:);
  end
  Meta.Sources = cat(1,S{:})'; % make a column vector
  Meta.Label = label;
  Meta = {Meta};%make a cell
  
  % helper recursive function
  function S = recurseSources(thisSource,label)
    if nargin < 2, label = ''; end
    thisName = thisSource.Name;
    thisLabel = {label,h5readatt(fileName,thisName,'label')};
    thisLabel(cellfun(@isempty,thisLabel,'UniformOutput',1)) = [];
    thisLabel = strjoin(thisLabel,' > ');
    propsInds = endsWith({thisSource.Groups.Name}','/properties');
    thisAttr = thisSource.Groups(propsInds).Attributes;
    S = struct( ...
      'Name', {thisLabel}, ...
      'Properties', cell2struct({thisAttr.Value}',{thisAttr.Name}') ...
      );
    subIdx = contains({thisSource.Groups.Name},'/sources');
    if ~any(subIdx), return; end
    subLinks = thisSource.Groups(subIdx).Links;
    if isempty(subLinks), return; end
    for lnk = 1:numel(subLinks)
      RecursedSources = recurseSources( ...
        h5info(fileName,subLinks(lnk).Value{1}), ...
        thisLabel ...
        );
      S = [ S; RecursedSources(:) ]; %#ok<AGROW>
    end
  end
end
function Data = getDataV2(grp)
  datumGroups = grp.Groups(contains({grp.Groups.Name}', '/epochGroups'));
  % Collect metainfo from epoch group.
  blockPropGroups = arrayfun( ...
    @(g)g.Groups(contains({g.Groups.Name}','/properties')), ...
    datumGroups.Groups, ...
    'UniformOutput', 0 ...
    );
  
  % collect the properties from each epoch block as an ordered struct
  % need to allow for EMPTY epochgroup properties
  blockProps = cell(numel(blockPropGroups),1);
  for gp = 1:numel(blockPropGroups)
    blk = blockPropGroups{gp};
    if isempty(blk) || isempty(blk.Attributes)
      blockProps{gp} = struct();
      continue
    end
    blockProps{gp} = orderfields( ...
      cell2struct( ...
        {blk.Attributes.Value}', ...
        matlab.lang.makeValidName({blk.Attributes.Name}') ...
        ) ...
      );
  end
  
  % get each epochGroup Label
  groupNames = arrayfun( ...
    @(grp) h5readatt(fileName,grp.Name, 'label'), ...
    datumGroups.Groups, ...
    'UniformOutput', 0 ...
    );
  
  for gp = 1:numel(blockProps)
    % grab the block Label
    blockProps{gp}.Label= groupNames{gp};
    
    % get the source name from 1 of 2 places:
    % either in epochGroups.Groups.Link(name=='source')
    % or in epochGroups.Groups.Group(endswith=='\source').att.label
    thisBlock = datumGroups.Groups(gp);
    isInLinks = ismember({thisBlock.Links.Name},'source');
    if any(isInLinks)
      % found in links, read the link attr 'label'
      theseSrcLinks = thisBlock.Links(isInLinks);
      theseSrcLinks = [theseSrcLinks.Value];
      sourceLabels = cellfun( ...
        @(sl) ...
          h5readatt(fileName,sl,'label'), ...
        theseSrcLinks, ...
        'uniformoutput', false ...
        );
    else
      % not found in link
      theseSrcLinks = contains({thisBlock.Groups.Name},'/source');
      theseSrcLinks = thisBlock.Groups(theseSrcLinks);
      sourceLabels = arrayfun( ...
        @(sl) ...
          h5readatt(fileName,sl.Name,'label'), ...
        theseSrcLinks, ...
        'UniformOutput', false ...
        );
    end
    % store the source label
    blockProps{gp}.Sources = strjoin(sourceLabels,'>');
  end
  
  % Get the protocol Block
  protocolGroups = arrayfun( ...
    @(a) a.Groups( ...
      contains({a.Groups.Name}','/epochBlocks') ...
      ).Groups, ...
    datumGroups.Groups, ...
    'UniformOutput', 0 ...
    );
  if all(cellfun(@isempty,protocolGroups,'unif',1))
    error("No protocols found.");
  end
  % expand blockProps
  blockProps = utilities.rep(blockProps,1,cellfun(@length,protocolGroups,'unif',1));
  
  protocolBlocks = cat(1,protocolGroups{:});
  [protocolStartTime,protocolOrder] = sort(arrayfun( ...
    @(e) sec2str( ...
      h5readatt(fileName, e.Name, 'startTimeDotNetDateTimeOffsetTicks'), ...
      h5readatt(fileName, e.Name, 'startTimeDotNetDateTimeOffsetOffsetHours') ...
      ), ...
    protocolBlocks, ...
    'UniformOutput', 0 ...
    ));
  
  %sort by start time
  protocolBlocks = protocolBlocks(protocolOrder);
  blockProps = blockProps(protocolOrder);
  
  % Find the Protocol parameters common to all Datums of a run protocol
  protocolParamBlocks = arrayfun( ...
    @(a) a.Groups(contains({a.Groups.Name}','/protocolParameters')), ...
    protocolBlocks, ...
    'UniformOutput', 0 ...
    );
  protocolParamBlocks = cat(1,protocolParamBlocks{:});
  
  % Get the epoch blocks: 1 elem in array for each epoch
  % using numel to return 0 if there are no epochs in a group. The proto for
  % loop will drop any empty blocks.
  numDatumsPerRun = arrayfun( ...
    @(a) numel(a.Groups(contains({a.Groups.Name}','/Epochs','IgnoreCase',true)).Groups), ...
    protocolBlocks, ...
    'UniformOutput', 1 ...
    );
  datumBlocks = arrayfun( ...
    @(a) a.Groups(contains({a.Groups.Name}','/Epochs','IgnoreCase',true)).Groups, ...
    protocolBlocks, ...
    'UniformOutput', 0 ...
    );
  
  blockProps = utilities.rep(blockProps,1, cellfun(@length,datumBlocks,'unif',1));
  datumBlocks = cat(1,datumBlocks{:});
  [DatumStartTime,datumOrder] = sort(arrayfun( ...
    @(e) sec2str( ...
      h5readatt(fileName, e.Name, 'startTimeDotNetDateTimeOffsetTicks'), ...
      h5readatt(fileName, e.Name, 'startTimeDotNetDateTimeOffsetOffsetHours') ...
      ), ...
    datumBlocks, ...
    'UniformOutput', 0 ...
    ));
  
  % sort by start time -> this will also help with combining nested props
  datumBlocks = datumBlocks(datumOrder);
  blockProps = blockProps(datumOrder);
  
  %Datum Params
  datumParamBlocks = arrayfun( ...
    @(blk)blk.Groups(contains({blk.Groups.Name}','/protocolParameters')), ...
    datumBlocks, ...
    'UniformOutput', 1 ...
    );
  
  %%% Merge the params
  % Start at protocol Level
  numProtocolsRun = numel(numDatumsPerRun);
  tmpArray = arrayfun( ...
    @(v,ofst)(1:v)+ofst, ...
    numDatumsPerRun, ...
    cumsum([0;numDatumsPerRun(1:end-1)]), ...
    'UniformOutput', 0 ...
    );
  propsInCells = cell(numProtocolsRun,1);
  for proto = 1:numProtocolsRun
    fields = [ ...
      {'protocolStartTime'}; ...
      {'protocolID'}; ...
      {protocolParamBlocks(proto).Attributes.Name}' ...
      ];
    values = [ ...
      protocolStartTime(proto); ...
      h5readatt(fileName, protocolBlocks(proto).Name,'protocolID'); ...
      {protocolParamBlocks(proto).Attributes.Value}' ...
      ];
    tmpInds = tmpArray{proto};
    tmpCell = cell(length(tmpInds),1);
    for ep = tmpInds
      tmpCell{ep-tmpInds(1)+1} = ...
        [ ...
          [ ...
            fields; ...
            {'DatumStartTime'}; ...
            {datumParamBlocks(ep).Attributes.Name}' ...
          ], ...
          [ ...
            values; ...
            DatumStartTime(ep); ...
            {datumParamBlocks(ep).Attributes.Value}' ...
          ] ...
        ];
    end
    propsInCells{proto} = tmpCell;
  end
  % Convert to epoch length
  propsInCells = cat(1, propsInCells{:});
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  nDatums = numel(propsInCells);
  Data(nDatums,1) = struct( ...
    'protocols', {{}}, ...
    'displayProperties', {{}}, ...
    'id', '', ...
    'responses', struct() ...
    );
    
  %%% Collect all the available information
  [datumResponses,datumBackgrounds,datumStimuli] = deal(cell(nDatums,1));
  for ep = 1:nDatums
    blk = datumBlocks(ep);
    
    % responses
    datumResponses{ep} = blk.Groups(contains({blk.Groups.Name}','/responses')).Groups;
    % output device configurations
    datumBackgrounds{ep} = blk.Groups(contains({blk.Groups.Name}','/backgrounds'));
    % stimuli
    datumStimuli{ep} = blk.Groups(contains({blk.Groups.Name}','/stimuli'));
  end
  
  numDatumsInRunRep = utilities.rep(numDatumsPerRun,1,numDatumsPerRun);
  curDatumInRun = arrayfun( ...
    @(v)(1:v), ...
    numDatumsPerRun, ...
    'UniformOutput', 0 ...
    );
  curDatumInRun = cat(2,curDatumInRun{:});
  % temp vars
  
  for rGroup = 1:nDatums
    responseStruct = datumResponses{rGroup};
    nResponses = length(responseStruct);
    responseData = struct( ...
      'sampleRate', {{}}, ...
      'duration', {{}}, ...
      'units', {{}}, ...
      'device', {{}}, ...
      'x', {{}}, ...
      'y', {{}} ...
      );
    for r = 1:nResponses
      responseMap = responseStruct(r);
      rlink = responseMap.Links( ...
        contains({responseMap.Links.Name}','device') ...
        ).Value{:};
      responseData.devices{r} = h5readatt(fileName, rlink,'name');
      d = h5read(fileName,[responseMap.Name,'/data']);
      responseData.y{r} = d.quantity;
      responseData.units{r} = struct( ...
        'x', {'sec'}, ...
        'y', unique(cellstr(d.units'),'stable') ...
        );
      fs = double(h5readatt(fileName, ...
        responseMap.Name, ...
        'sampleRate' ...
        ));
      responseData.sampleRate{r} = fs;
      dur = double(h5readatt(fileName, ...
          [responseMap.Name,'/dataConfigurationSpans/span_0'], ...
          'timeSpanSeconds' ...
        ));
      responseData.duration{r} = dur;
      startTimeSec = h5readatt(fileName, ...
          [responseMap.Name,'/dataConfigurationSpans/span_0'], ...
          'startTimeSeconds' ...
        );
      % set X to a function handle from a formatted string
      responseData.x{r} = str2func(sprintf( ...
        '@()((1:%d)-1)''./%.0f + %.4f', ...
        length(responseData.y{r}), ...
        fs, ...
        startTimeSec ...
        ));
    end
    % Get configuration for each stimulus data
    nConfigs = length(datumStimuli{rGroup}.Groups);
    responseData.stimulusConfiguration = struct( ...
      'deviceName', '', ...
      'configSettings', struct('name', '', 'value', {{}}) ...
      );
    for cfg = 1:nConfigs
      responseData.stimulusConfiguration(cfg).deviceName = ...
        h5readatt(fileName, ...
          datumStimuli{rGroup}.Groups(cfg).Links( ...
            ismember({datumStimuli{rGroup}.Groups(cfg).Links.Name}','device') ...
          ).Value{1}, ...
          'name' ...
        );
      
      configLoc = h5info(fileName, ...
        [datumStimuli{rGroup}.Groups(cfg).Groups( ...
        contains( ...
          {datumStimuli{rGroup}.Groups(cfg).Groups.Name}', ...
          '/dataConfigurationSpans' ...
          ) ...
        ).Name,'/span_0/',responseData.stimulusConfiguration(cfg).deviceName ...
        ]);
      paramLoc = datumStimuli{rGroup}.Groups(cfg).Groups( ...
        endsWith( ...
          {datumStimuli{rGroup}.Groups(cfg).Groups.Name}', ...
          '/parameters' ...
          ) ...
        );
      theseAttributes = [ ...
        configLoc.Attributes; ...
        paramLoc.Attributes; ...
        datumStimuli{rGroup}.Groups(cfg).Attributes ...
        ];
      theseAttributes(ismember({theseAttributes.Name},'uuid')) = [];
      for cset = 1:length(theseAttributes)
        responseData.stimulusConfiguration(cfg).configSettings(cset) = ...
          struct( ...
            'name', theseAttributes(cset).Name, ...
            'value', theseAttributes(cset).Value ...
            );
      end
    end
    % Get configuuration for output devices
    nBackgrounds = length(datumBackgrounds{rGroup}.Groups);
    responseData.deviceConfiguration = struct( ...
      'deviceName', '', ...
      'configSettings', struct('name', '', 'value', {{}}) ...
      );
    for cfg = 1:nBackgrounds
      responseData.deviceConfiguration(cfg).deviceName = ...
        h5readatt(fileName, ...
          datumBackgrounds{rGroup}.Groups(cfg).Links( ...
            ismember({datumBackgrounds{rGroup}.Groups(cfg).Links.Name}','device') ...
          ).Value{1}, ...
          'name' ...
          );
      configLoc = h5info(fileName,...
        [datumBackgrounds{rGroup}.Groups(cfg).Groups( ...
        contains( ...
          {datumBackgrounds{rGroup}.Groups(cfg).Groups.Name}', ...
          '/dataConfigurationSpans' ...
          ) ...
        ).Name,'/span_0/',responseData.deviceConfiguration(cfg).deviceName ...
        ]);
      paramLoc = datumBackgrounds{rGroup}.Groups(cfg);
      theseAttributes = [ configLoc.Attributes; paramLoc.Attributes ];
      theseAttributes(ismember({theseAttributes.Name},'uuid')) = [];
      for cset = 1:length(theseAttributes)
        responseData.deviceConfiguration(cfg).configSettings(cset) = ...
          struct( ...
            'name', theseAttributes(cset).Name, ...
            'value', theseAttributes(cset).Value ...
            );
      end
    end
    % create list of existing devices for checking response devices
    gatheredDevices = { ...
      responseData.deviceConfiguration.deviceName, ...
      responseData.stimulusConfiguration.deviceName ...
      };
    % gather configurations from response devices and append them to deviceConf.
    for r = 1:nResponses
      responseMap = responseStruct(r);
      % get the device name
      rlink = responseMap.Links( ...
        contains({responseMap.Links.Name}','device') ...
        ).Value{:};
      deviceName = h5readatt(fileName, rlink,'name');
      % avoid duplicates in the case of stimulus and response on same device
      if ismember(deviceName,gatheredDevices)
        continue
      end
      configLoc = h5info( ...
        fileName, ...
        sprintf( ...
          '%s/%s/%s', ...
          responseMap.Name, ...
          'dataConfigurationSpans/span_0', ...
          deviceName ...
          ) ...
        );
      if isempty(configLoc.Attributes), continue; end
      theseAttributes = configLoc.Attributes;
      % store
      responseData.deviceConfiguration(nBackgrounds + r).deviceName = deviceName;
      for cset = 1:length(theseAttributes)
        responseData.deviceConfiguration(nBackgrounds + r).configSettings(cset) = ...
          struct( ...
            'name', theseAttributes(cset).Name, ...
            'value', theseAttributes(cset).Value ...
            );
      end
    end
    % append to the data group
    Data(rGroup,1).responses = responseData;
    Data(rGroup,1).protocols = propsInCells{rGroup};
    % display props
    displayNames = propsInCells{rGroup}( ...
      ismember(propsInCells{rGroup}(:,1), ...
        { ...
        'amplifierHoldingPotential', 'protocolID', 'sampleRate'
        } ...
      ), ...
      1 ...
      );
    displayValues = propsInCells{rGroup}( ...
      ismember(propsInCells{rGroup}(:,1), displayNames), ...
      2 ...
      );
    % check for epochStartTime from Symphony protocol
    dateTimeLoc = ismember(propsInCells{rGroup}(:,1),'epochDateString');
    if any(dateTimeLoc)
      dateAndTime = strsplit(propsInCells{rGroup}{dateTimeLoc,2},'_');
    else
      % use dotnet ticks if epochDateString not found
      dateTimeLoc = ismember(propsInCells{rGroup}(:,1),'DatumStartTime');
      dateAndTime = strsplit(propsInCells{rGroup}{dateTimeLoc,2},' ');
      dateAndTime{1} = strrep(dateAndTime{1},'-','');
    end
    % Get names for the display field
    displayName = [ ...
      displayNames(:); ...
      { ...
        'NumDatumsInRun'; 'CurrentDatumInRun'; 'Date'; 'Time' ...
      } ...
      ];
    displayValues = [ ...
      displayValues(:); ...
      { ...
        numDatumsInRunRep(rGroup); curDatumInRun(rGroup); ...
        dateAndTime{1}; dateAndTime{2} ...
      } ...
      ];
    % append in blockProperties
    Data(rGroup,1).displayProperties = [ ...
      [ ...
        displayName(:); ...
        fieldnames(blockProps{rGroup}); ...
        fileInfo(:,1) ...
      ],[ ...
        displayValues(:); ...
        struct2cell(blockProps{rGroup}); ...
        fileInfo(:,2) ...
      ] ...
      ];
  end %end of data collection loop
  
end

end %end of reader

%% Helpers
function [ tString,varargout ] = sec2str( secs, ofst )
  if nargin < 2, ofst = 0; end
  % offset is the number of hours from UTC
  ofst = 60^2 * ofst;
  tString = cell(numel(secs),1);
  for i = 1:numel(secs)
    thisTick = uint64(double(secs(i))+ofst);
    tString{i} = datestr( ...
      datetime( ...
        thisTick, ...
        'ConvertFrom', '.net' ...
        ), ...
      'mmm-DD-YYYY HH:MM:SS.FFF' ...
      );
  end
  varargout{1} = tString;
  if numel(tString) == 1
    tString = tString{:};
  end
end

function tsec = str2sec(str)
  spt = strsplit(str,':');
  nums = str2double(flipud(spt(:))); %s,m,h now
  tsec = 0;
  for nn = 1:length(nums)
    tsec = nums(nn)*60^(nn-1) + tsec;
  end
end